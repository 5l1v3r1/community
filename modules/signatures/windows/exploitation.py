# Copyright (C) 2016 Cuckoo Foundation.
# This file is part of Cuckoo Sandbox - http://www.cuckoosandbox.org
# See the file 'docs/LICENSE' for copying permission.

from lib.cuckoo.common.abstracts import Signature

class ExploitHeapspray(Signature):
    name = "exploit_heapspray"
    description = "A heapspray has been detected"
    severity = 3
    categories = ["exploit"]
    authors = ["Cuckoo Technologies"]
    minimum = "2.0"

    filter_apinames = "NtAllocateVirtualMemory",

    def init(self):
        self.mem = {}
        self.prot = {}
        self.ignore = False
        self.whitelist = ["PE32 executable"]
        
        if self.get_results("target", {}).get("category") == "file":
            filetype = self.get_results("target", {})["file"]["type"]
            for ignore in self.whitelist:
                if ignore in filetype:
                    self.ignore = True

    def on_call(self, call, process):
        pname = process["process_name"]
        pid = call["arguments"]["process_identifier"]
        protection = call["arguments"]["protection"]
        alloc_type = call["arguments"]["allocation_type"]
        region_size = call["arguments"]["region_size"]
        allocation_typefull = call["flags"].get("allocation_type")

        if allocation_typefull == "MEM_COMMIT":
            combo = pname, pid, region_size, protection, alloc_type
            self.mem[combo] = self.mem.get(combo, 0) + 1
            self.prot[protection] = call["flags"].get("protection")

    def on_complete(self):
        if not self.ignore:
            for combo, count in self.mem.items():
                pname, pid, region_size, protection, alloc_type = combo

                if count >= 50:
                    written = int(region_size) * int(count)/1024/1024
                    self.mark(
                        process=pname,
                        name="heapspray",
                        protection=self.prot.get(protection, protection),
                        count=count,
                        length=region_size,
                        total_mb=written,
                    )

        return self.has_marks()
